#!/bin/bash
#
# Top-level script that runs all components of the end-to-end
# system
#
# Just run 'polycc <C code>' when the program section to
# be parallelized/optimized around special comments as described
# in the `README'
#
# Copyright (C) 2007-2008 Uday Bondhugula
#
# This file is available under the MIT license. Please see LICENSE in the
# top-level directory for details.
#
pluto=@abs_top_builddir@/tool/pluto
inscop=@abs_top_srcdir@/inscop

# Some additional setup here to ensure that variables are visible outside of the
# run function.
SOURCEFILE=""
OUTFILE=""
dirname=""
PLUTOOUT=""
GEN_TRAHRHE=0
formatter_bin=$(which clang-format)

if [ -z ${TRAHRHE_PATH+x} ]; then
  trahrhe_bin="trahrhe"
else
  trahrhe_bin="${TRAHRHE_PATH}/trahrhe"
fi
trahrhe_dir="$(dirname $(which $trahrhe_bin))"
trahrhe_opt_file=".trahrhe"

# check for command-line options
for arg in $*; do
  if [ $arg == "--parallel" ]; then
    PARALLEL=1
  elif [ $arg == "--parallelize" ]; then
    PARALLEL=1
  elif [ $arg == "--unroll" ]; then
    UNROLL=1
  elif [ $arg == "--debug" ]; then
    DEBUG=1
  elif [ $arg == "--moredebug" ]; then
    DEBUG=1
  elif [ $arg == "-i" ]; then
    INDENT=1
  elif [ $arg == "--indent" ]; then
    INDENT=1
  elif [ $arg == "--silent" ]; then
    SILENT=1
  elif [ $arg == "--gentrahrhe" ]; then
    GEN_TRAHRHE=1
  fi
done

# some special processing for linearized accesses
#if [ "$SOURCEFILE" != "" ]; then
#grep __SPECIAL $SOURCEFILE > .nonlinearized
#grep __SPECIAL $SOURCEFILE | sed -e "s/.*__SPECIAL//" > .linearized
#fi

run() {
  $pluto $* || exit 1

  SOURCEFILE=$(cat .srcfilename)
  OUTFILE=$(cat .outfilename)

  dirname=$(dirname $SOURCEFILE)
  basename=$(basename $SOURCEFILE)
  prefix=$(basename $SOURCEFILE .c)

  CLOOGFILE=$(basename $OUTFILE).pluto.cloog
  PLUTOOUT=$OUTFILE

  # put the original skeleton around the transformed code
  $inscop $SOURCEFILE $OUTFILE $OUTFILE

  if [ "$INDENT" == 1 ] && [ -x "$formatter_bin" ]; then
    $formatter_bin --style=LLVM -i $OUTFILE
  fi

  if [[ $GEN_TRAHRHE -eq 1 ]]; then
    trahrhe_compute_number=$(sed '1q;d' $trahrhe_opt_file)
    trahrhe_compute_number=$(($trahrhe_compute_number - 1))
    for i in $(seq 0 $trahrhe_compute_number); do
      # compute line numbers of .trahrhe file
      trahrhe_line_offset=$((2 + $i * 4))
      trahrhe_line_domain=$(($trahrhe_line_offset))
      trahrhe_line_max_lvl=$(($trahrhe_line_offset + 1))
      trahrhe_line_mask=$(($trahrhe_line_offset + 2))
      trahrhe_line_hd_name=$(($trahrhe_line_offset + 3))

      # retrieve isl domain, header name, and max tiling level
      trahrhe_isl_domain=$(sed "${trahrhe_line_domain}q;d" $trahrhe_opt_file)
      trahrhe_header_name=$(sed "${trahrhe_line_hd_name}q;d" $trahrhe_opt_file)
      trahrhe_max_lvl=$(sed "${trahrhe_line_max_lvl}q;d" $trahrhe_opt_file)
      trahrhe_mask=$(sed "${trahrhe_line_mask}q;d" $trahrhe_opt_file)

      # display info
      if [[ $SILENT -eq 0 ]]; then
        echo "[trahrhe] header name = $trahrhe_header_name"
        echo "[trahrhe] isl domain = $trahrhe_isl_domain"
        echo "[trahrhe] tiling level = $trahrhe_max_lvl"
        echo "[trahrhe] mask = $trahrhe_mask"
        echo "[trahrhe] Generating tiling header..."
      fi
      # call trahrhe
      (cd "$trahrhe_dir" && ./trahrhe -d"$trahrhe_isl_domain" -e -t "$trahrhe_max_lvl" -m "$trahrhe_mask" >.trahrhe.log)
      mv "$trahrhe_dir/.trahrhe.log" .trahrhe.log
      mv "$trahrhe_dir/trahrhe_tiling_header.h" $trahrhe_header_name
      # trahrhe header correction
      sed -i "s/TILEMIN/TILEMIN_$i/" $trahrhe_header_name
      # generation done
    done
  fi
}

run "$*"
WORK=1
TEMPFILE=""
while [ $WORK -eq 1 ]; do
  if grep -q "#pragma scop" "$PLUTOOUT"; then
    # Move the original file into a temporary location
    TEMPFILE="$SOURCEFILE""_temp"
    mv $SOURCEFILE $TEMPFILE

    # Move the file that still has scope in it into
    # place of the original source file, so $* will pick the
    # correct file
    mv $PLUTOOUT $SOURCEFILE

    # Run pluto again
    run "$*"

    # Move the original back in place
    mv $TEMPFILE $SOURCEFILE
  else
    # No more scops
    WORK=0
  fi
done

cleanup() {
  # An attempt to move the original file back in place
  # in the event of an exception.
  if [ -f "$TEMPFILE" ]; then
    mv $TEMPFILE $SOURCEFILE
  fi
  if [ "$DEBUG" != 1 ]; then
    rm -f .regtile .vectorize .pragmas .params .orcc .linearized .nonlinearized \
      $CLOOGFILE .srcfilename .outfilename .distmem pi.cloog sigma.cloog \
      *.sysloog .appendfilename
  fi
}

trap cleanup SIGINT exit
